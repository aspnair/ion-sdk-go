# ION-SFU RTP

## Features
This application can take RTP from remote and forward received RTP from SFU to remote.
- RTP streams could be generated from anywhere.
- For simplicity, separate gstreamer scripts are used as RTP source and destination.
- All communication with gstreamer are with udpsrc and udpsink on either loopback, unicast or multicast.
- Instead of gstreamer, any other RTP streams could be used, including from IP Camera, generated by VLC etc.
- This application can also manage two streams - first normal stream and the second presentation screen share simulation stream.
- Received peer RTP streams from SFU could be forwarded to a decoding gstreamer pipeline to decode audio and video for both first stream and the remote presentation screen share stream.
- Every incoming RTP stream and track is analyzed for packet losses.  This is applicable for both the gstreamer generated local RTP streams and the SFU forwarded remote RTP streams.
- All the streams and tracks related stats are printed periodically (stat_interval in main.go) and during application exit with SIGINT or SIGTERM signals.
- This also joins the room and periodically sends messages to all other clients.
- There is a run script included so that multiple ion-sfu-rtp client processes could be started to simulate load on SFU.

## Requirement
- Currently this example is tested on Debian GNU/Linux and Ubuntu only.

### gstreamer
- Install gstreamer

`sudo apt-get install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-tools`

### ion
- Install the ion servers as given at
[https://pionion.github.io](https://pionion.github.io/)


### ion-app-web
- Install [ion-app-web](https://github.com/pion/ion-app-web)
- Start the development server using `npm start`
- Better to have a camera and mic for the browser client connecting to this server.

## Use cases

### Command line help
- To get command line of different applications, open a shell and try the following
```
./gst.sh
go run main.go -help
./run.sh
```
- The **default codecs are VP8 and Opus**. In order to use H.264 codec, do export **VCODEC environment**. This has to be used for each shell before starting the script and the application.
```
export VCODEC=H264
```

### Basic gstreamer encode and decode
- As a basic step, make sure that gstreamer scripts are working by entering the following commands on **two** different shells.

```
./gst.sh -e 2
./gst.sh -d 2 225.0.0.225 21000
```
- Two separate gstreamer video displays should be opened.  The first one with [SMPTE pattern](https://en.wikipedia.org/wiki/SMPTE_color_bars) and the second one with a moving ball.
- This also produces an audio [acoustics beat](https://en.wikipedia.org/wiki/Beat_(acoustics)) with 1Hz audible beat frequency.  The beat is useful to understand that two audio streams are coming properly.

### Basic call with a browser client
- open a browser client to connect to the ion-app-web npm server.  Join the room.
- Open **two** different shells and run the following commands in any order.
```
./gst.sh -e 1
go run main.go -addr "localhost:5551" -session "ion"
```
- Now the browser client should display the SMPTE pattern with a single 1000 Hz tone.

### Call with a browser client with ion-sfu-rtp sending screen share also
- Join the room from the browser client
- Open **two** different shells and run the following commands in any order.
```
./gst.sh -e 2
go run main.go -addr "localhost:5551" -session "ion" -nr_stream 2
```
- Now the browser client should display both the SMPTE pattern and the moving ball with the audible beat.
- The screen share stream is started after a delay (delay_stream in main.go code)

### Call with a browser client with both ion-sfu-rtp and the browser sending screen share
- Open **three** different shells and run the following commands in any order.
```
./gst.sh -e 2
./gst.sh -d 2
go run main.go -addr "localhost:5551" -session "ion" -nr_stream 2 -rtp_fwd 1
```
- Now join the room from the browser client, better to start the browser client after the above commands so that the key video frames are not missed.
- Start a screen share presentation from the browser client
- Now the browser client should display both the SMPTE pattern and the moving ball with the audible beat
- As both RTP forward and the gstreamer decode pipeline are started, two separate video displays should be opened.  One for the main camera video from the browser and the second for the screen share.
- Use rtp_fwd only with one client to avoid confusion to the gstreamer decode pipeline.

### Multiple clients to load the SFU
- Open **two** different shells and run the following commands.
- For example, to start 5 clients with 2 streams per client with session name ion
```
./gst.sh -e 2
./run.sh ion 5 2
./run.sh stop
```
- Better to start the gstreamer encode script first.
- The run script would spawn multiple ion-sfu-rtp client processes and all of them take the same encoded streams from the multicast ports.
- Now, a browser client also could be opened to monitor all of them.
- It could be stopped with the same run script with stop parameter.

## Frequently Asked Questions (FAQ)
- Why the gstreamer script is provided separately?
  - The ion-sfu-rtp Go application becomes simple, it just listens for RTP packets on UDP ports.
  - There is no need to use Cgo at all.
  - Instead of gstreamer any other RTP generating application or system could be used.
  - The gstreamer script could be easily modified for different scenario.
  - With the help of the optional gstreamer decode script, bidirection calls could be easily simulated.
- What is the use of multicast IP in the gstreamer script and the ion-sfu-rtp main application?
  - By default both the gstreamer script and the ion-sfu-rtp main application uses 225.0.0.225 multicast group.
  - This could be easily overridden by arguments from both the main application and the gstreamer script.
  - With multicast group, the gstreamer script could be run on any other computer also.
  - Multiple ion-sfu-rtp clients could also be started on different computers.
  - With multicast, only one audio and video source and encoder is required, for any number of clients.

